  module SFMainMod

  ! ============================================================================
  ! All subroutines related to the SPITFIRE fire routine. 
  ! Code originally developed by Allan Spessa & Rosie Fisher as part of the NERC-QUEST project.  
  ! ============================================================================

  use FatesConstantsMod     , only : r8 => fates_r8
  use FatesConstantsMod     , only : itrue, ifalse
  use FatesConstantsMod     , only : pi_const
  use FatesConstantsMod     , only : nocomp_bareground
  use FatesInterfaceTypesMod, only : hlm_masterproc ! 1= master process, 0=not master process
  use FatesGlobals          , only : fates_log
  use FatesInterfaceTypesMod, only : hlm_spitfire_mode
  use FatesInterfaceTypesMod, only : hlm_sf_nofire_def
  use FatesInterfaceTypesMod, only : hlm_sf_scalar_lightning_def
  use FatesInterfaceTypesMod, only : hlm_sf_successful_ignitions_def
  use FatesInterfaceTypesMod, only : hlm_sf_anthro_ignitions_def
  use FatesInterfaceTypesMod, only : bc_in_type
  use EDPftvarcon           , only : EDPftvarcon_inst
  use PRTParametersMod      , only : prt_params
  use PRTGenericMod         , only : element_pos
  use EDtypesMod            , only : ed_site_type
  use FatesPatchMod         , only : fates_patch_type
  use FatesCohortMod        , only : fates_cohort_type
  use EDtypesMod            , only : AREA
  use FatesFuelMod          , only : NFSC
  use FatesFuelMod          , only : DL_SF
  use FatesFuelMod          , only : TW_SF
  use FatesFuelMod          , only : LB_SF
  use FatesFuelMod          , only : LG_SF
  use FatesFuelMod          , only : TR_SF
  use FatesLitterMod        , only : litter_type
  use PRTGenericMod,          only : carbon12_element
  use PRTGenericMod,          only : leaf_organ
  use PRTGenericMod,          only : sapw_organ
  use PRTGenericMod,          only : struct_organ
  use FatesInterfaceTypesMod, only : numpft
  use FatesAllometryMod,      only : CrownDepth
  use EDTypesMod,             only : CalculateCoverFraction

  implicit none
  private

  public :: fire_model
  public :: UpdateFuelCharacteristics
  public :: CalcEffectiveWindSpeed
  public :: rate_of_spread
  public :: ground_fuel_consumption
  public :: area_burnt_intensity
  public :: crown_scorching
  public :: crown_damage
  public :: cambial_damage_kill
  public :: post_fire_mortality

  ! The following parameter represents one of the values of hlm_spitfire_mode
  ! and more of these appear in subroutine area_burnt_intensity below
  ! NB. The same parameters are set in /src/biogeochem/CNFireFactoryMod
  logical :: write_SF = .false.  ! for debugging
  logical :: debug = .false.     ! for debugging

  ! ======================================================================================

  contains

  subroutine fire_model(currentSite, bc_in)
    !
    ! DESCRIPTION:
    !  Runs main SPITFIRE code across all patches on a FATES site
    !
    ! ARGUMENTS:
    type(ed_site_type), intent(inout), target :: currentSite ! site object
    type(bc_in_type),   intent(in)            :: bc_in       ! site driver data object

    ! LOCALS:
    type(fates_patch_type), pointer :: currentPatch     ! patch to work with

    real(r8)                        :: canopy_fuel_load ! available canopy fuel load in patch [kg biomass]
    real(r8)                        :: passive_crown_FI ! fire intensity for ignition of passive canopy fuel [kW/m]
    real(r8)                        :: ROS_torch        ! ROS for crown torch initation [m/min]
    real(r8)                        :: lb               ! length to breadth ratio of fire ellipse [unitless]
    real(r8)                        :: heat_per_area    ! heat release per unit area [kJ/m2] for surface fuel

    ! zero fire things
    currentPatch => currentSite%youngest_patch
    do while(associated(currentPatch))
      
      currentPatch%frac_burnt            = 0.0_r8
      currentPatch%FI                    = 0.0_r8
      currentPatch%FD                    = 0.0_r8
      currentPatch%fire                  = 0
      currentPatch%active_crown_fire_flg = 0
      
      currentPatch => currentPatch%older
    enddo

    if (write_SF) write(fates_log(), *) 'spitfire_mode', hlm_spitfire_mode

    if (hlm_spitfire_mode > hlm_sf_nofire_def) then
      call UpdateFireWeather(currentSite, bc_in)
      call UpdateFuelCharacteristics(currentSite)
      call rate_of_spread(currentSite, passive_crown_FI, ROS_torch, heat_per_area)
      call ground_fuel_consumption(currentSite)
      call area_burnt_intensity(currentSite, bc_in, lb)
      call crown_scorching(currentSite)
      call crown_damage(currentSite)
      call cambial_damage_kill(currentSite)
      call post_fire_mortality(currentSite)
    end if

  end subroutine fire_model

  !=======================================================================================

  subroutine UpdateFireWeather(currentSite, bc_in)
    !
    ! DESCRIPTION:
    !  Calculates site-level fire weather and fire danger indices
    !
    use FatesConstantsMod, only : tfrz => t_water_freeze_k_1atm
    use FatesConstantsMod, only : sec_per_day, sec_per_min

    ! ARGUMENTS:
    type(ed_site_type), intent(inout), target :: currentSite ! FATES site object
    type(bc_in_type),   intent(in)            :: bc_in       ! driver data
    
    ! LOCALS:
    type(fates_patch_type), pointer :: currentPatch ! FATES patch object
    real(r8)                        :: temp_in_C    ! daily averaged temperature [degrees C]
    real(r8)                        :: rainfall     ! daily precip in [mm/day]
    real(r8)                        :: rh           ! daily rh [%]
    real(r8)                        :: wind         ! daily wind speed [m/min]
    integer                         :: iofp         ! index of oldest the fates patch

    ! NOTE that the boundary conditions of temperature, precipitation and relative humidity
    ! are available at the patch level. We are currently using a simplification where the whole site
    ! is simply using the values associated with the first patch.
    ! which probably won't have much inpact, unless we decide to ever calculate fire weather for each patch.  
    currentPatch => currentSite%oldest_patch

    ! If the oldest patch is a bareground patch (i.e. nocomp mode is on) use the first vegetated patch
    ! for the iofp index (i.e. the next younger patch)
    if (currentPatch%nocomp_pft_label == nocomp_bareground) then
      currentPatch => currentPatch%younger
    end if
    iofp = currentPatch%patchno

    temp_in_C = currentPatch%tveg24%GetMean() - tfrz
    rainfall = bc_in%precip24_pa(iofp)*sec_per_day
    rh = bc_in%relhumid24_pa(iofp)
    wind = bc_in%wind24_pa(iofp)*sec_per_min 

    ! calculate fire weather indices
    call currentSite%fireWeather%Update(temp_in_C, rainfall, rh, wind)

    ! add wind speed to fire weather class
    currentSite%fireWeather%wind_speed = wind

    ! calculate effective wind speed
    call CalcEffectiveWindSpeed(currentSite)
    
  end subroutine UpdateFireWeather

  !=======================================================================================

  subroutine CalcEffectiveWindSpeed(currentSite)
    !
    ! DESCRIPTION:
    !  Calculate effective windspeed based on vegetation characteristics
    !  Influence of surface roughness on wind speed averaged over whole
    !  gridcell to reduce divergence between patches
    !
    
    ! ARGUMENTS:
    type(ed_site_type), intent(inout), target :: currentSite ! site object

    ! LOCALS:
    real(r8) :: tree_fraction  ! site-level tree fraction [0-1]
    real(r8) :: grass_fraction ! site-level grass fraction [0-1]
    real(r8) :: bare_fraction  ! site-level bare fraction [0-1]
    
    ! calculate the cover fractions
    call CalculateCoverFraction(currentSite, tree_fraction, grass_fraction, bare_fraction)

    ! update effective wind speed
    call currentSite%fireWeather%UpdateEffectiveWindSpeed(tree_fraction, grass_fraction, &
      bare_fraction)

  end subroutine CalcEffectiveWindSpeed

  ! ======================================================================================

  subroutine UpdateFuelCharacteristics(currentSite)
    !
    ! DESCRIPTION:
    !  Calculates fuel characterestics for each patch
    !
    use SFParamsMod, only: SF_val_SAV, SF_val_FBD, SF_val_miner_total

    ! ARGUMENTS: 
    type(ed_site_type), intent(in), target :: currentSite ! site object

    ! LOCALS:
    type(fates_patch_type), pointer :: currentPatch ! patch object
    type(litter_type),      pointer :: litt_c       ! litter object
    real(r8)                        :: live_grass   ! live grass on patch [kg/m2]
    real(r8)                        :: sav          ! fuel surface area to volume ratio [/cm]
    integer                         :: l            ! looping index for litter class

    currentPatch => currentSite%oldest_patch
    do while (associated(currentPatch))  

      if (currentPatch%nocomp_pft_label /= nocomp_bareground) then

        litt_c => currentPatch%litter(element_pos(carbon12_element))

        ! sum live grass for fuel [kg/m2]
        call currentPatch%SumLiveGrass(live_grass)

        ! sum up litter
        call currentPatch%fuel%CalculateLoading(litt_c, live_grass)

        do l = 1, nfsc
          ! live grass moisture is a function of SAV and changes via Nesterov Index
          ! along the same relationship as the 1 hour fuels (live grass has same SAV as dead grass,
          ! but retains more moisture with this calculation)
          if (l == lg_sf) then 
            sav = SF_val_SAV(tw_sf)
          else 
            sav = SF_val_SAV(l)
          end if 
          currentPatch%fuel%moisture(l) = currentSite%fireWeather%CalcFuelMoisture(sav)
        end do

        ! average geometric characteristics across all fuel classes
        call currentPatch%fuel%UpdateGeometry(SF_val_FBD, SF_val_SAV)

        ! average moisture conditions
        call currentPatch%fuel%UpdateMoisture(SF_val_SAV)

      end if

      currentPatch => currentPatch%younger

    end do 

  end subroutine UpdateFuelCharacteristics

  !=======================================================================================

  subroutine rate_of_spread(currentSite, ROS_torch, passive_crown_FI, heat_per_area)
    !
    ! DESCRIPTION:
    !  Calculates rate of spread for each patch

    use SFParamsMod, only : SF_val_miner_total, SF_val_part_dens, SF_val_miner_damp
    use SFParamsMod, only : SF_val_fuel_energy

    ! ARGUMENTS:
    type(ed_site_type), intent(in), target :: currentSite       ! site object
    real(r8),           intent(out)        :: ROS_torch         ! ROS for crown torch initation (m/min)
    real(r8),           intent(out)        :: heat_per_area     ! heat release per unit area (kJ/m2) for surface fuel
    real(r8),           intent(in)         :: passive_crown_FI  ! min fire intensity to ignite canopy fuel (kW/m or kJ/m/s)

    ! LOCALS:
    type(fates_patch_type), pointer :: currentPatch   ! patch object
    real(r8)                        :: beta           ! packing ratio [unitless]
    real(r8)                        :: beta_opt       ! optimum packing ratio [unitless]
    real(r8)                        :: beta_ratio     ! ratio of packing ratio to optimum packing ratio [unitless]
    real(r8)                        :: reaction_v_opt ! reaction velocity [/min]
    real(r8)                        :: moist_damp     ! moisture dampening coefficient [0-1]

    real(r8) ir                   ! reaction intensity (kJ/m2/min)
    real(r8) xi,eps,phi_wind      ! all are unitless
    real(r8) q_ig                 ! heat of pre-ignition (kJ/kg)
    real(r8) b,c,e              ! function of fuel sav
    real(r8) time_r               ! residence time (min)

    real(r8), parameter :: q_dry = 581.0_r8             !heat of pre-ignition of dry fuels (kJ/kg)
    real(r8), parameter :: wind_reduce = 0.2_r8         !wind reduction factor (%)

    currentPatch => currentSite%oldest_patch
    do while(associated(currentPatch))

      if (currentPatch%nocomp_pft_label /= nocomp_bareground) then

        ! ---initialise parameters to zero.--- 
        q_ig = 0.0_r8; eps = 0.0_r8;   b = 0.0_r8;   c = 0.0_r8;   e = 0.0_r8
        phi_wind = 0.0_r8;   xi = 0.0_r8;   
        moist_damp = 0.0_r8;   ir = 0.0_r8;   
        currentPatch%ROS_front = 0.0_r8

        ! packing ratio and optimum packing ratio
        beta = PackingRatio(currentPatch%fuel%bulk_density, SF_val_part_dens)
        beta_opt = OptimumPackingRatio(currentPatch%fuel%SAV)
        beta_ratio = beta/beta_opt

        ! optimum reaction velocity [/min]
        reaction_v_opt = OptimumReactionVelocity(currentPatch%fuel%SAV, beta_ratio)

        ! moisture dampening coefficient [unitless]
        moist_damp = MoistureDampeningCoeff(currentPatch%fuel%av_moisture,               &
          currentPatch%fuel%MEF)

        currentPatch%fuel%total_sum = currentPatch%fuel%total_sum * (1.0_r8 - SF_val_miner_total) !net of minerals
        
        ! reaction intenisty [kJ/m2/min]
        ! currentPatch%sum_fuel converted from kgC/m2 to kgBiomass/m2 for ir calculation
        ir = reaction_v_opt*(currentPatch%fuel%total_sum/0.45_r8)*SF_val_fuel_energy*moist_damp*SF_val_miner_damp 

        ! ---heat of pre-ignition---
        !  Eq A4 in Thonicke et al. 2010, Eq 12 Rothermel 1972
        !  50 Btu/lb + 1116 Btu/lb * fuel_eff_moist
        !  conversion of Rothermel (1972) Eq 12 in BTU/lb to current kJ/kg 
        !  q_ig in kJ/kg 
        q_ig = q_dry + 2594.0_r8 * currentPatch%fuel%av_moisture

        ! ---effective heating number---
        ! Eq A3 in Thonicke et al. 2010.  
        eps = exp(-4.528_r8 / currentPatch%fuel%SAV)     
        ! Eq A7 in Thonicke et al. 2010 per Eq 49 Rothermel 1972
        b = 0.15988_r8 * (currentPatch%fuel%SAV**0.54_r8)
        ! Eq A8 in Thonicke et al. 2010 per Eq 48 Rothermel 1972 
        c = 7.47_r8 * (exp(-0.8711_r8 * (currentPatch%fuel%SAV**0.55_r8)))
        ! Eq A9 in Thonicke et al. 2010. (has typo, using coefficient Eq 50 Rothermel 1972)
        e = 0.715_r8 * (exp(-0.01094_r8 * currentPatch%fuel%SAV))

        ! Eq A5 in Thonicke et al. 2010
        ! phi_wind (unitless)
        ! convert current_wspeed (wind at elev relevant to fire) from m/min to ft/min for Rothermel ROS eqn
        phi_wind = c * ((3.281_r8*currentSite%fireWeather%effective_wind_speed)**b)*(beta_ratio**(-e))

        ! ---propagating flux----
        ! Eq A2 in Thonicke et al.2010 and Eq 42 Rothermel 1972
        ! xi (unitless)       
        xi = (exp((0.792_r8 + 3.7597_r8 * (currentPatch%fuel%SAV**0.5_r8)) * (beta+0.1_r8))) / &
          (192_r8+7.9095_r8 * currentPatch%fuel%SAV)      

        if (((currentPatch%fuel%bulk_density) <= 0.0_r8).or.(eps <= 0.0_r8).or.(q_ig <= 0.0_r8)) then
          currentPatch%ROS_front = 0.0_r8
          ROS_torch = 0.0_r8   
        else ! Eq 9. Thonicke et al. 2010. 
          ! forward ROS in m/min
          currentPatch%ROS_front = (ir*xi*(1.0_r8+phi_wind)) / (currentPatch%fuel%bulk_density*eps*q_ig)

          ! calculate heat release per unit area (HPA)(kJ/m2), Eq 2 Scott & Reinhardt 2001
          ! and residence time (min), Eq 3 Scott & Reinhardt 2001
          time_r = 12.595 / currentPatch%fuel%SAV 
          heat_per_area = ir * time_r          

          ! calculate torching index based on wind speed and crown fuels 
          ! ROS for crown torch initation (m/min), Eq 18 Scott & Reinhardt 2001 
          ROS_torch = (1.0 / 54.683 * wind_reduce)* &
            ((((60.0*passive_crown_FI*currentPatch%fuel%bulk_density*eps*q_ig)/heat_per_area*ir*xi)-1.0) &
              / (c*beta_ratio)**(-1*e))**1/b
        end if
        ! Eq 10 in Thonicke et al. 2010
        ! backward ROS from Can FBP System (1992) in m/min
        ! backward ROS wind not changed by vegetation 
        currentPatch%ROS_back = currentPatch%ROS_front*exp(-0.012_r8*currentSite%fireWeather%wind_speed) 

      end if 
      currentPatch => currentPatch%younger

    end do 

  end subroutine  rate_of_spread

  ! ======================================================================================

  subroutine  ground_fuel_consumption(currentSite) 
  !returns the  the hypothetic fuel consumed by the fire

  use SFParamsMod, only : SF_val_miner_total, SF_val_min_moisture, &
    SF_val_mid_moisture, SF_val_low_moisture_Coeff, SF_val_low_moisture_Slope, &
    SF_val_mid_moisture_Coeff, SF_val_mid_moisture_Slope

  type(ed_site_type) , intent(in), target :: currentSite
  type(fates_patch_type), pointer    :: currentPatch
  type(litter_type), pointer      :: litt_c           ! carbon 12 litter pool

  real(r8) :: moist           !effective fuel moisture
  real(r8) :: tau_b(nfsc)     !lethal heating rates for each fuel class (min) 
  real(r8) :: fc_ground(nfsc) !total amount of fuel consumed per area of burned ground (kg C / m2 of burned area)
  real(r8) :: live_grass

  integer  :: c

  currentPatch => currentSite%oldest_patch;  

    do while(associated(currentPatch))

      if(currentPatch%nocomp_pft_label .ne. nocomp_bareground)then

      currentPatch%burnt_frac_litter(:) = 1.0_r8       
      ! Calculate fraction of litter is burnt for all classes. 
      ! Eq B1 in Thonicke et al. 2010---
      do c = 1, nfsc    !work out the burnt fraction for all pools, even if those pools dont exist.         
        moist = currentPatch%fuel%moisture(c)                  
        ! 1. Very dry litter
        if (moist <= SF_val_min_moisture(c)) then
          currentPatch%burnt_frac_litter(c) = 1.0_r8  
        endif
        ! 2. Low to medium moistures
        if (moist > SF_val_min_moisture(c).and.moist <= SF_val_mid_moisture(c)) then
          currentPatch%burnt_frac_litter(c) = max(0.0_r8,min(1.0_r8,SF_val_low_moisture_Coeff(c)- &
          SF_val_low_moisture_Slope(c)*moist)) 
        else
          ! For medium to high moistures. 
          if (moist > SF_val_mid_moisture(c).and.moist <= 1.0_r8) then
            currentPatch%burnt_frac_litter(c) = max(0.0_r8,min(1.0_r8,SF_val_mid_moisture_Coeff(c)- &
              SF_val_mid_moisture_Slope(c)*moist))
          endif

        endif
        ! Very wet litter        
        if (moist >= 1.0_r8) then !this shouldn't happen? 
          currentPatch%burnt_frac_litter(c) = 0.0_r8  
        endif          
      enddo !c   

      ! we can't ever kill -all- of the grass. 
      currentPatch%burnt_frac_litter(lg_sf) = min(0.8_r8,currentPatch%burnt_frac_litter(lg_sf ))  

      ! reduce burnt amount for mineral content. 
      currentPatch%burnt_frac_litter(:) = currentPatch%burnt_frac_litter(:) * (1.0_r8-SF_val_miner_total) 

      !---Calculate amount of fuel burnt.---    

      call currentPatch%SumLiveGrass(live_grass)

      litt_c => currentPatch%litter(element_pos(carbon12_element))
      FC_ground(tw_sf:tr_sf) = currentPatch%burnt_frac_litter(tw_sf:tr_sf) * litt_c%ag_cwd(tw_sf:tr_sf)
      FC_ground(dl_sf)       = currentPatch%burnt_frac_litter(dl_sf)   * sum(litt_c%leaf_fines(:))
      FC_ground(lg_sf)       = currentPatch%burnt_frac_litter(lg_sf)   * live_grass     

      ! Following used for determination of cambial kill follows from Peterson & Ryan (1986) scheme 
      ! less empirical cf current scheme used in SPITFIRE which attempts to mesh Rothermel 
      ! and P&R, and while solving potential inconsistencies, actually results in BIG values for 
      ! fire residence time, thus lots of vegetation death!   
      ! taul is the duration of the lethal heating.  
      ! The /10 is to convert from kgC/m2 into gC/cm2, as in the Peterson and Ryan paper #Rosie,Jun 2013

      do c = 1,nfsc  
        tau_b(c)   =  39.4_r8 *(currentPatch%fuel%frac(c)*currentPatch%fuel%total_sum/0.45_r8/10._r8)* &
          (1.0_r8-((1.0_r8-currentPatch%burnt_frac_litter(c))**0.5_r8))  
      enddo
      tau_b(tr_sf)   =  0.0_r8
      ! Cap the residence time to 8mins, as suggested by literature survey by P&R (1986).
      currentPatch%tau_l = min(8.0_r8,sum(tau_b)) 

      !---calculate overall fuel consumed by spreading fire --- 
      ! ignore 1000hr fuels. Just interested in fuels affecting ROS   
      currentPatch%TFC_ROS = sum(FC_ground)-FC_ground(tr_sf)  

    end if ! nocomp_pft_label check

    currentPatch=>currentPatch%younger;
    enddo !end patch loop

  end subroutine ground_fuel_consumption


  !*****************************************************************
  subroutine  area_burnt_intensity ( currentSite, bc_in, lb)
  !*****************************************************************

  !returns the updated currentPatch%FI value for each patch.

  !currentPatch%FI  avg fire intensity of flaming front during day. Backward ROS plays no role here. kJ/m/s or kW/m.
  !currentSite%FDI  probability that an ignition will start a fire
  !currentSite%NF   number of lighting strikes per day per km2
  !currentPatch%ROS_front  forward ROS (m/min) 
  !currentPatch%TFC_ROS total fuel consumed by flaming front (kgC/m2 of burned area)

  use FatesInterfaceTypesMod, only : hlm_spitfire_mode  ! TODO slevis: redundant?
  use EDParamsMod,       only : ED_val_nignitions
  use EDParamsMod,       only : cg_strikes    ! fraction of cloud-to-ground ligtning strikes
  use FatesConstantsMod, only : years_per_day
  use SFParamsMod,       only : SF_val_fdi_alpha,SF_val_fuel_energy, &
                SF_val_max_durat, SF_val_durat_slope, SF_val_fire_threshold

  type(ed_site_type), intent(inout), target :: currentSite
  type(fates_patch_type), pointer :: currentPatch
  type(bc_in_type), intent(in) :: bc_in

  ! ARGUMENTS
  real(r8), intent(out) :: lb      !length to breadth ratio of fire ellipse (unitless)

  ! LOCAL VARIABLES
  real(r8) ROS                     !rate of spread (m/s)
  real(r8) W                       !available fuel (kgBiomass/m2)
  real(r8) :: tree_fraction_patch  !patch level. no units
  real(r8) df                      !distance fire has travelled forward (m)
  real(r8) db                      !distance fire has travelled backward (m)
  real(r8) AB                      !daily area burnt (m2 per km2)
  real(r8) size_of_fire            !in m2
  real(r8) cloud_to_ground_strikes ! [fraction] depends on hlm_spitfire_mode
  real(r8) anthro_ign_count        ! anthropogenic ignition count/km2/day
  integer :: iofp                  ! index of oldest fates patch
  real(r8), parameter :: pot_hmn_ign_counts_alpha = 0.0035_r8  ! Potential human ignition counts (alpha in Li et al. 2012) (#/person/month)
  real(r8), parameter :: km2_to_m2 = 1000000.0_r8              ! area conversion for square km to square m
  real(r8), parameter :: m_per_min__to__km_per_hour = 0.06_r8  ! convert wind speed from m/min to km/hr
  real(r8), parameter :: forest_grassland_lengthtobreadth_threshold = 0.55_r8 ! tree canopy cover below which to use 
                                                              ! grassland length-to-breadth eqn
                                                              ! 0.55 = benchmark forest cover, Staver 2010

  !  ---initialize site parameters to zero--- 
  currentSite%NF_successful = 0._r8

  ! Eq 7 from Venevsky et al GCB 2002 (modification of Eqn 8, Thonicke et al. 2010) 
  ! FDI 0.1 = low, 0.3 moderate, 0.75 high, and 1 = extreme ignition potential for alpha 0.000337
  if (hlm_spitfire_mode == hlm_sf_successful_ignitions_def) then
    currentSite%FDI = 1.0_r8           ! READING "SUCCESSFUL IGNITION" DATA
                          ! force ignition potential to be extreme
    cloud_to_ground_strikes = 1.0_r8   ! cloud_to_ground = 1 = use 100% incoming observed ignitions
  else  ! USING LIGHTNING DATA
    currentSite%FDI  = 1.0_r8 - exp(-SF_val_fdi_alpha*currentSite%fireWeather%fire_weather_index)
    cloud_to_ground_strikes = cg_strikes
  end if

  currentPatch => currentSite%oldest_patch

  ! If the oldest patch is a bareground patch (i.e. nocomp mode is on) use the first vegetated patch
  ! for the iofp index (i.e. the next younger patch)
  if(currentPatch%nocomp_pft_label .eq. nocomp_bareground)then
    currentPatch => currentPatch%younger
  endif

  !NF = number of lighting strikes per day per km2 scaled by cloud to ground strikes
  iofp = currentPatch%patchno
  if (hlm_spitfire_mode == hlm_sf_scalar_lightning_def ) then
    currentSite%NF = ED_val_nignitions * years_per_day * cloud_to_ground_strikes
  else    ! use external daily lightning ignition data
    currentSite%NF = bc_in%lightning24(iofp) * cloud_to_ground_strikes
  end if

  ! If there are 15  lightning strikes per year, per km2. (approx from NASA product for S.A.) 
  ! then there are 15 * 1/365 strikes/km2 each day 

  ! Calculate anthropogenic ignitions according to Li et al. (2012)
  ! Add to ignitions by lightning
  if (hlm_spitfire_mode == hlm_sf_anthro_ignitions_def) then
    ! anthropogenic ignitions (count/km2/day)
    !           =  ignitions/person/month * 6.8 * population_density **0.43 /approximate days per month
    anthro_ign_count = pot_hmn_ign_counts_alpha * 6.8_r8 * bc_in%pop_density(iofp)**0.43_r8 / 30._r8
            
    currentSite%NF = currentSite%NF + anthro_ign_count
  end if

  currentPatch => currentSite%oldest_patch;  
  do while(associated(currentPatch))

    if(currentPatch%nocomp_pft_label .ne. nocomp_bareground)then

      !  ---initialize patch parameters to zero---
      currentPatch%FI         = 0._r8
      currentPatch%fire       = 0
      currentPatch%FD         = 0.0_r8
      currentPatch%frac_burnt = 0.0_r8

      if (currentSite%NF > 0.0_r8) then

        ! Eq 14 in Thonicke et al. 2010
        ! fire duration in minutes
        currentPatch%FD = (SF_val_max_durat+1.0_r8) / (1.0_r8 + SF_val_max_durat * &
                exp(SF_val_durat_slope*currentSite%FDI))
        if(write_SF)then
          if ( hlm_masterproc == itrue ) write(fates_log(),*) 'fire duration minutes',currentPatch%fd
        endif
        !Eq 15 in Arora and Boer CTEM model.Average fire is 1 day long.
        !currentPatch%FD = 60.0_r8 * 24.0_r8 !no minutes in a day

        tree_fraction_patch  = 0.0_r8
        tree_fraction_patch  = currentPatch%total_tree_area/currentPatch%area

        if(debug)then
          write(fates_log(),*) 'SF  currentPatch%area ',currentPatch%area
          write(fates_log(),*) 'SF  currentPatch%total_area ',currentPatch%total_tree_area
          write(fates_log(),*) 'SF  patch tree fraction ',tree_fraction_patch
          write(fates_log(),*) 'SF  AREA ',AREA
        endif         

        if ((currentSite%fireWeather%effective_wind_speed*m_per_min__to__km_per_hour) < 1._r8) then !16.67m/min = 1km/hr 
          lb = 1.0_r8
        else
          if (tree_fraction_patch > forest_grassland_lengthtobreadth_threshold) then 
          ! Eq 79 forest fuels (Canadian Forest Fire Behavior Prediction System Ont.Inf.Rep. ST-X-3, 1992)
            lb = (1.0_r8 + (8.729_r8 * &
              ((1.0_r8 -(exp(-0.03_r8 * m_per_min__to__km_per_hour * currentSite%fireWeather%effective_wind_speed)))**2.155_r8)))
          else ! Eq 80 grass fuels (CFFBPS Ont.Inf.Rep. ST-X-3, 1992, with correction from errata published in 
            ! Inf.Rep. GLC-X-10 (Bottom et al., 2009) because of typo in CFFBPS Ont.Inf.Rep. ST-X-3, 1992)
            lb = (1.1_r8*((m_per_min__to__km_per_hour * currentSite%fireWeather%effective_wind_speed)**0.464_r8))
          endif
        endif

        !     if (lb > 8.0_r8)then
        !       lb = 8.0_r8  !Constraint Canadian Fire Behaviour System
        !     endif
        ! ---- calculate length of major axis---
        db = currentPatch%ROS_back  * currentPatch%FD !m
        df = currentPatch%ROS_front * currentPatch%FD !m

        ! --- calculate area burnt---
        if(lb > 0.0_r8) then

          ! Eq 1 in Thonicke et al. 2010
          ! To Do: Connect here with the Li & Levis GDP fire suppression algorithm. 
          ! Eq 16 in arora and boer model JGR 2005
          ! AB = AB *3.0_r8

          !size of fire = Eq 14 Arora and Boer JGR 2005 (area of an ellipse)
          size_of_fire = ((pi_const/(4.0_r8*lb))*((df+db)**2.0_r8))

          ! AB = daily area burnt = size fires in m2 * num ignitions per day per km2 * prob ignition starts fire
          ! AB = m2 per km2 per day
          ! the denominator in the units of currentSite%NF is total gridcell area, but since we assume that ignitions 
          ! are equally probable across patches, currentSite%NF is equivalently per area of a given patch
          ! thus AB has units of m2 burned area per km2 patch area per day
          AB = size_of_fire * currentSite%NF * currentSite%FDI

          ! frac_burnt 
          ! just a unit conversion from AB, to become area burned per area patch per day, 
          ! or just the fraction of the patch burned on that day
          currentPatch%frac_burnt = (min(0.99_r8, AB / km2_to_m2))

          if(write_SF)then
          if ( hlm_masterproc == itrue ) write(fates_log(),*) 'frac_burnt',currentPatch%frac_burnt
          endif

        else
          currentPatch%frac_burnt = 0._r8
        endif ! lb

        ROS   = currentPatch%ROS_front / 60.0_r8 !m/min to m/sec for FI calculation
        W     = currentPatch%TFC_ROS / 0.45_r8   !kgC/m2 of burned area to kgbiomass/m2 of burned area

        ! Eq 15 Thonicke et al 2010
        !units of fire intensity = (kJ/kg)*(kgBiomass/m2)*(m/sec)
        currentPatch%FI = SF_val_fuel_energy * W * ROS  !kj/m/s, or kW/m

        if(write_sf)then
          if( hlm_masterproc == itrue ) write(fates_log(),*) 'fire_intensity',currentPatch%fi,W,currentPatch%ROS_front
        endif

        !'decide_fire' subroutine 
        if (currentPatch%FI > SF_val_fire_threshold) then !track fires greater than kW/m energy threshold
          currentPatch%fire = 1 ! Fire...    :D
          !
          currentSite%NF_successful = currentSite%NF_successful + &
          currentSite%NF * currentSite%FDI * currentPatch%area / area
        !
        else     
          currentPatch%fire       = 0 ! No fire... :-/
          currentPatch%FD         = 0.0_r8
          currentPatch%frac_burnt = 0.0_r8
        endif         

      endif ! NF ignitions check
    endif ! nocomp_pft_label check

    currentPatch => currentPatch%younger

  enddo !end patch loop

  end subroutine area_burnt_intensity

  !*****************************************************************
  subroutine  crown_scorching ( currentSite ) 
  !*****************************************************************

  !currentPatch%FI       average fire intensity of flaming front during day.  kW/m.
  !currentPatch%SH(pft)  scorch height for all cohorts of a given PFT on a given patch (m)

  type(ed_site_type), intent(in), target :: currentSite

  type(fates_patch_type), pointer  :: currentPatch
  type(fates_cohort_type), pointer :: currentCohort

  real(r8) ::  tree_ag_biomass ! total amount of above-ground tree biomass in patch. kgC/m2
  real(r8) ::  leaf_c          ! leaf carbon      [kg]
  real(r8) ::  sapw_c          ! sapwood carbon   [kg]
  real(r8) ::  struct_c        ! structure carbon [kg]

  integer  ::  i_pft


  currentPatch => currentSite%oldest_patch;  
  do while(associated(currentPatch)) 

    if(currentPatch%nocomp_pft_label .ne. nocomp_bareground)then

      tree_ag_biomass = 0.0_r8
      if (currentPatch%fire == 1) then
        currentCohort => currentPatch%tallest;
        do while(associated(currentCohort))  
          if ( prt_params%woody(currentCohort%pft) == itrue) then !trees only

            leaf_c = currentCohort%prt%GetState(leaf_organ, carbon12_element)
            sapw_c = currentCohort%prt%GetState(sapw_organ, carbon12_element)
            struct_c = currentCohort%prt%GetState(struct_organ, carbon12_element)

            tree_ag_biomass = tree_ag_biomass + &
              currentCohort%n * (leaf_c + & 
              prt_params%allom_agb_frac(currentCohort%pft)*(sapw_c + struct_c))
          endif !trees only
          currentCohort=>currentCohort%shorter;
        enddo !end cohort loop

        do i_pft=1,numpft
          if (tree_ag_biomass > 0.0_r8  .and. prt_params%woody(i_pft) == itrue) then 

            !Equation 16 in Thonicke et al. 2010 !Van Wagner 1973 EQ8 !2/3 Byram (1959)
            currentPatch%Scorch_ht(i_pft) = EDPftvarcon_inst%fire_alpha_SH(i_pft) * (currentPatch%FI**0.667_r8)

            if(write_SF)then
              if ( hlm_masterproc == itrue ) write(fates_log(),*) 'currentPatch%SH',currentPatch%Scorch_ht(i_pft)
            endif
          else
            currentPatch%Scorch_ht(i_pft) = 0.0_r8
          endif ! tree biomass
        end do

      endif !fire
    endif !nocomp_pft_label

    currentPatch => currentPatch%younger;  
  enddo !end patch loop

  end subroutine crown_scorching


  !*****************************************************************
  subroutine  crown_damage ( currentSite )
  !*****************************************************************

  !returns the updated currentCohort%fraction_crown_burned for each tree cohort within each patch.
  !currentCohort%fraction_crown_burned is the proportion of crown affected by fire

  type(ed_site_type), intent(in), target :: currentSite

  type(fates_patch_type) , pointer :: currentPatch
  type(fates_cohort_type), pointer :: currentCohort

  real(r8) ::  crown_depth          ! depth of crown (m)
  real(r8) ::  height_cbb           ! clear branch bole height or crown base height (m) for cohort

  currentPatch => currentSite%oldest_patch

  do while(associated(currentPatch))
    !zero Patch level variables
    if(currentPatch%nocomp_pft_label .ne. nocomp_bareground)then
      if (currentPatch%fire == 1) then

        currentCohort=>currentPatch%tallest

        do while(associated(currentCohort))  
          currentCohort%fraction_crown_burned = 0.0_r8
          if ( int(prt_params%woody(currentCohort%pft)) == itrue) then !trees

            ! height_cbb = clear branch bole height at base of crown (m)
            ! inst%crown = crown_depth_frac (PFT)
            call CrownDepth(currentCohort%height,currentCohort%pft,crown_depth)
            height_cbb   = currentCohort%height - crown_depth

            ! Equation 17 in Thonicke et al. 2010
            ! flames over bottom of canopy, and potentially over top of
            ! canopy
            if (currentCohort%height > 0.0_r8 .and. &
              currentPatch%Scorch_ht(currentCohort%pft) >= height_cbb) then
              if (currentPatch%active_crown_fire_flg == 0) then
                currentCohort%fraction_crown_burned = min(1.0_r8, &
                ((currentPatch%Scorch_ht(currentCohort%pft) - height_cbb) / crown_depth))
              else  ! active crown fire occurring
                currentCohort%fraction_crown_burned = 1.0_r8
              end if
            endif  !SH frac crown burnt calculation
            ! Check for strange values. 
            currentCohort%fraction_crown_burned = min(1.0_r8, max(0.0_r8,currentCohort%fraction_crown_burned))              
          endif !trees only
          !shrink canopy to account for burnt section.     
          !currentCohort%canopy_trim = min(currentCohort%canopy_trim,(1.0_r8-currentCohort%fraction_crown_burned)) 

          currentCohort => currentCohort%shorter;

        enddo !end cohort loop

      endif !fire?
    endif !nocomp_pft_label check

    currentPatch => currentPatch%younger;

  enddo !end patch loop

  end subroutine crown_damage

  !*****************************************************************
  subroutine  cambial_damage_kill ( currentSite ) 
  !*****************************************************************
  ! routine description.
  ! returns the probability that trees dies due to cambial char
  ! currentPatch%tau_l = duration of lethal stem heating (min). Calculated at patch level.

  type(ed_site_type), intent(in), target :: currentSite

  type(fates_patch_type) , pointer :: currentPatch
  type(fates_cohort_type), pointer :: currentCohort

  real(r8) :: tau_c !critical time taken to kill cambium (minutes) 
  real(r8) :: bt    !bark thickness in cm.

  currentPatch => currentSite%oldest_patch;  

  do while(associated(currentPatch)) 

    if(currentPatch%nocomp_pft_label .ne. nocomp_bareground)then

      if (currentPatch%fire == 1) then
        currentCohort => currentPatch%tallest;
        do while(associated(currentCohort))
          currentCohort%cambial_mort = 0.0_r8
          if ( int(prt_params%woody(currentCohort%pft)) == itrue) then !trees only
            ! Equation 21 in Thonicke et al 2010
            bt = EDPftvarcon_inst%bark_scaler(currentCohort%pft)*currentCohort%dbh ! bark thickness. 
            ! Equation 20 in Thonicke et al. 2010. 
            tau_c = 2.9_r8*bt**2.0_r8 !calculate time it takes to kill cambium (min)
            ! Equation 19 in Thonicke et al. 2010
            if ((currentPatch%tau_l/tau_c) >= 2.0_r8) then
              currentCohort%cambial_mort = 1.0_r8
            else
              if ((currentPatch%tau_l/tau_c) > 0.22_r8) then
                currentCohort%cambial_mort = (0.563_r8*(currentPatch%tau_l/tau_c)) - 0.125_r8
              else
                currentCohort%cambial_mort = 0.0_r8
              endif
            endif
          endif !trees 

          currentCohort => currentCohort%shorter;

        enddo !end cohort loop
      endif !fire?
    endif !nocomp_pft_label check

    currentPatch=>currentPatch%younger;

  enddo !end patch loop

  end subroutine cambial_damage_kill

  !*****************************************************************
  subroutine  post_fire_mortality ( currentSite )
  !*****************************************************************

  !  returns the updated currentCohort%fire_mort value for each tree cohort within each patch.
  !  currentCohort%fraction_crown_burned is proportion of crown affected by fire
  !  currentCohort%crownfire_mort  probability of tree post-fire mortality due to crown scorch
  !  currentCohort%cambial_mort  probability of tree post-fire mortality due to cambial char
  !  currentCohort%fire_mort  post-fire mortality from cambial and crown damage assuming two are independent.

  type(ed_site_type), intent(in), target :: currentSite

  type(fates_patch_type),  pointer :: currentPatch
  type(fates_cohort_type), pointer :: currentCohort

  currentPatch => currentSite%oldest_patch

    do while(associated(currentPatch)) 

    if(currentPatch%nocomp_pft_label .ne. nocomp_bareground)then

      if (currentPatch%fire == 1) then 
        currentCohort => currentPatch%tallest
        do while(associated(currentCohort))  
          currentCohort%fire_mort = 0.0_r8
          currentCohort%crownfire_mort = 0.0_r8
          if ( prt_params%woody(currentCohort%pft) == itrue) then
            ! Equation 22 in Thonicke et al. 2010. 
            currentCohort%crownfire_mort = EDPftvarcon_inst%crown_kill(currentCohort%pft)*currentCohort%fraction_crown_burned**3.0_r8
            ! Equation 18 in Thonicke et al. 2010. 
            currentCohort%fire_mort = max(0._r8,min(1.0_r8,currentCohort%crownfire_mort+currentCohort%cambial_mort- &
              (currentCohort%crownfire_mort*currentCohort%cambial_mort)))  !joint prob.   
          else
            currentCohort%fire_mort = 0.0_r8 !Set to zero. Grass mode of death is removal of leaves.
          endif !trees

          currentCohort => currentCohort%shorter

          enddo !end cohort loop
        endif !fire?
      endif !nocomp_pft_label check

    currentPatch => currentPatch%younger

  enddo !end patch loop

  end subroutine post_fire_mortality

  ! ======================================================================================

  real(r8) function PackingRatio(bulk_density, particle_density)
    ! DESCRIPTION:
    !   Calculates packing ratio (beta, unitless) of fuel based on Pyne et al. 1996
    !   Fraction of fuel array volume occupied by fuel, or compactness of fuel bed 
    !    particle_density is equal to 513 kg/m3 in Pyne et al. 1996
    !

    ! ARGUMENTS:
    real(r8), intent(in) :: bulk_density     ! bulk density of fuel [kg/m3]
    real(r8), intent(in) :: particle_density ! oven-dry particle density [kg/m3]

    PackingRatio = bulk_density/particle_density

  end function PackingRatio

  !=======================================================================================

  real(r8) function OptimumPackingRatio(sav)
    ! DESCRIPTION:
    !   Calculates optimum packing ratio (unitless) of fuel based on Thonicke et al. 2010
    !   Eq A6 in Thonicke et al. 2010
    !

    ! ARGUMENTS:
    real(r8), intent(in) :: sav ! fuel surface area to volume ratio [/cm]

    OptimumPackingRatio = 0.200395_r8*(sav**(-0.8189_r8))

  end function OptimumPackingRatio 

  !=======================================================================================

  real(r8) function MaximumReactionVelocity(sav)
    ! DESCRIPTION:
    !   Calculates maximum reaction velocity [/min]
    !

    ! ARGUMENTS:
    real(r8), intent(in) :: sav ! fuel surface area to volume ratio [/cm]

    MaximumReactionVelocity = 1.0_r8/(0.0591_r8 + 2.926_r8* (sav**(-1.5_r8)))

  end function MaximumReactionVelocity 

  !=======================================================================================

  real(r8) function OptimumReactionVelocity(sav, beta_ratio)
    ! DESCRIPTION:
    !   Calculates optimum reaction velocity [/min]
    !   Indicates completeness and rate of fuel consumption
    !   Calculated as ratio of reaction zone efficiency to reaction time
    !   Equation is from Pyne et al. 1996
    !   Higher optimum reaction velocities result in higher rates of spread
    !   Low reaction velocities occur at two extremes of fuel compactness and particle size - 
    !       loose and dense. Loose beds - low velocities and ROS occur due to heat loss
    !       between particles. Dense beds - low velocities and ROS due to low air-to-fuel
    !       ratios and poor penetration of heat at depth

    ! ARGUMENTS:
    real(r8), intent(in) :: sav        ! fuel surface area to volume ratio [/cm]
    real(r8), intent(in) :: beta_ratio ! ratio of packing ratio to optimum packing ratio [unitless]

    ! LOCALS:
    real(r8) :: a, a_beta ! temporary variables

    ! Eqs in Table A1 Thonicke et al. 2010 
    a = 8.9033_r8 * (sav**(-0.7913_r8))
    a_beta = exp(a*(1.0_r8 - beta_ratio))  
    
    ! Eq 38 in Rothermel 1972 and Fig 11
    OptimumReactionVelocity = MaximumReactionVelocity(sav)*(beta_ratio**a)*a_beta

  end function OptimumReactionVelocity 

  !=======================================================================================

  real(r8) function MoistureDampeningCoeff(moisture, moisture_of_extinction)
    ! DESCRIPTION:
    ! Calculates moisture dampening coefficients, equation in Table A1 in Thonicke et al. 2010

    ! ARGUMENTS:
    real(r8), intent(in) :: moisture               ! fuel moisture [m3/m3]
    real(r8), intent(in) :: moisture_of_extinction ! fuel moisture of extinction [m3/m3]

    ! LOCALS:
    real(r8) :: mw_weight ! ratio of fuel moisture to MEF

    mw_weight = moisture/moisture_of_extinction

    MoistureDampeningCoeff = max(0.0_r8, (1.0_r8 - (2.59_r8*mw_weight) +                 &
      (5.11_r8*(mw_weight**2.0_r8)) - (3.52_r8*(mw_weight**3.0_r8))))

  end function MoistureDampeningCoeff 

  !=======================================================================================

  !real(r8) function ReactionIntensity()
  ! DESCRIPTION:
  ! Calculates moisture dampening coefficients, equation in Table A1 in Thonicke et al. 2010

  ! ARGUMENTS:
  !real(r8), intent(in) :: moisture               ! fuel moisture [m3/m3]
  !real(r8), intent(in) :: moisture_of_extinction ! fuel moisture of extinction [m3/m3]

  ! LOCALS:
  !real(r8) :: mw_weight ! ratio of fuel moisture to MEF

  !mw_weight = moisture/moisture_of_extinction

  !MoistureDampeningCoeff = max(0.0_r8, (1.0_r8 - (2.59_r8*mw_weight) +                 &
  !  (5.11_r8*(mw_weight**2.0_r8)) - (3.52_r8*(mw_weight**3.0_r8))))

  !end function ReactionIntensity 

!=======================================================================================
  
end module SFMainMod
